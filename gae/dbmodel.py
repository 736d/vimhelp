# Definitions of objects stored in Data Store and Memcache

from google.appengine.ext import db

# There is one of these objects in the datastore, to persist some bits of info
# that we need across update runs. keyname is "global".
class GlobalInfo(db.Model):
    index_etag = db.ByteStringProperty(indexed=False)
    # HTTP ETag of the vim repository index page for the 'runtime/doc' subdirectory

    hg_revision = db.ByteStringProperty(indexed=False)
    # Mercurial revision of the 'runtime/doc' subdirectory

    hgtags_etag = db.ByteStringProperty(indexed=False)
    # HTTP ETag of the .hgtags file, the last line of which contains the current Vim
    # version

    vim_version = db.ByteStringProperty(indexed=False)
    # Current Vim version

# Info related to an unprocessed documentation file from the repository; key
# name is basename, e.g. "help.txt"
class RawFileInfo(db.Model):
    etag = db.ByteStringProperty(indexed=False)
    # HTTP ETag of the file on the remote Mercurial repository

    redo = db.BooleanProperty(indexed=False)
    # Whether this file needs redoing, i.e. whether it should be re-processed at
    # the next update run even if no changes are found. This is set by the
    # "force" parameter to update.py.

    memcache_genid = db.IntegerProperty(indexed=False)
    # "Generation ID" of the corresponding memcache entry (if any). Used in
    # addition to the filename and part number in the memcache key to avoid race
    # conditions when retrieving a multi-part file while updating the parts.

# The actual contents of an unprocessed documentation file from the repository;
# key name is basename, e.g. "help.txt"
class RawFileData(db.Model):
    data = db.BlobProperty()
    # The contents

    encoding = db.ByteStringProperty(indexed=False)
    # The encoding, e.g. 'UTF-8'

# Info related to a processed (HTMLified) documentation file; key name is
# basename, e.g. "help.txt"
class ProcessedFileHead(db.Model):
    etag = db.ByteStringProperty(indexed=False)
    # HTTP ETag on this server, generated by us as a hash of the contents

    encoding = db.ByteStringProperty(indexed=False)
    # Encoding, always matches the corresponding 'RawFileData' object

    modified = db.DateTimeProperty(indexed=False)
    # Time when this file was generated

    numparts = db.IntegerProperty(indexed=False)
    # Number of parts; there will be 'numparts - 1' objects of kind
    # 'ProcessedFilePart' in the database. Processed files are split up into
    # parts as required by datastore blob limitations (currently these can only
    # be up to 1 MiB in size)

    data0 = db.BlobProperty()
    # Contents of the first (and possibly only) part

# Part of a processed file; keyname is basename + ":" + partnum (1-based), e.g.
# "help.txt:1"
class ProcessedFilePart(db.Model):
    data = db.BlobProperty()
    # Contents

# Processed file stored in memcache, name is basename, e.g. "help.txt"
class MemcacheHead(object):
    def __init__(self, head, genid):
        # 'head' must be a 'ProcessedFileInfo' object
        self.etag = head.etag
        self.encoding = head.encoding
        self.modified = head.modified
        self.numparts = head.numparts
        self.data0 = head.data0
        self.genid = genid

# For multi-part processed files, these objects are stored in memcache for
# additional parts beyond the first one; keyname is as returned by function
# 'memcache_part_name'
class MemcachePart(object):
    def __init__(self, part):
        # 'part' must be a 'ProcessedFileDataPart' object
        self.data = part.data

# Returns the name under which 'MemcachePart' objects are stored in memcache;
# note that this include the "genid" ("Generation ID"), used to prevent race
# conditions when a multi-part object is stored in memcache while being
# retrieved by someone else
def memcache_part_name(filename, genid, partnum):
    return '{}:{}:{}'.format(genid, filename, partnum)
